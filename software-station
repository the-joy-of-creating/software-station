#!/usr/bin/env python3
"""
Copyright (c) 2017-2025, GhostBSD. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistribution's of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

2. Redistribution's in binary form must reproduce the above
   copyright notice,this list of conditions and the following
   disclaimer in the documentation and/or other materials provided
   with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
"""

# Third-party imports
import gi
gi.require_version('Gtk', '3.0')

# Standard library imports
import threading
import pwd
import os
import gettext
import crypt
from time import sleep

from gi.repository import Gtk, GdkPixbuf, GLib, Gdk

# Local imports
from software_station_xpm import xpm_package_category
from software_station_pkg import (
    search_packages,
    available_package_origin,
    available_package_dictionary,
    get_pkg_changes_data,
    installed_package_origin,
    installed_package_dictionary,
    delete_packages,
    install_packages,
    fetch_packages,
    network_stat,
    repo_online,
    sync_with_repository,
    start_update_station,
    repository_is_syncing
)
from iconlist import (
    init_icons_runtime,
    themed_icon_and_label_async,
    themed_icon_and_label_sync,
)

# Configure gettext for internationalization
gettext.bindtextdomain('software-station', '/usr/local/share/locale')
gettext.textdomain('software-station')
_ = gettext.gettext

__VERSION__ = '2.0'

# pylint: disable=global-at-module-level
global pkg_to_install
pkg_to_install = []

global pkg_to_uninstall
pkg_to_uninstall = []


class TableWindow(
        Gtk.Window):  # pylint: disable=too-many-instance-attributes,too-many-public-methods
    """Main window for the Software Station GUI."""

    def __init__(self):
        super().__init__()
        self.set_title(_("Software Station"))
        self.connect("delete-event", Gtk.main_quit)
        self.set_size_request(850, 500)
        self.set_default_icon_name('system-software-install')
        # Creating the toolbar
        toolbar = Gtk.Toolbar()
        self.box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.add(self.box1)  # pylint: disable=no-member
        self.box1.show()
        self.box1.pack_start(toolbar, False, False, 0)
        self.previousbutton = Gtk.ToolButton()
        self.previousbutton.set_label(_("Back"))
        self.previousbutton.set_is_important(True)
        self.previousbutton.set_icon_name("go-previous")
        self.previousbutton.set_sensitive(False)
        self.nextbutton = Gtk.ToolButton()
        self.nextbutton.set_label(_("Forward"))
        self.nextbutton.set_is_important(True)
        self.nextbutton.set_icon_name("go-next")
        self.nextbutton.set_sensitive(False)

        self.desc_is_shown = False
        self.desc_toggle = Gtk.ToggleToolButton()
        self.desc_toggle.set_property("tooltip-text", _("Show Description"))
        self.desc_toggle.set_icon_name("view-list")
        self.desc_toggle.connect("toggled", self.toggle_description)
        self.desc_toggle.set_sensitive(False)
        toolbar.insert(self.desc_toggle, 3)

        self.available_toggle = Gtk.RadioToolButton(label=_("All Software"))
        self.available_toggle.set_property("tooltip-text", _("All Software"))
        self.available_toggle.set_icon_name("package_network")
        self.available_or_installed = 'available'
        self.available_toggle.connect(
            "toggled", self.all_or_installed, "available")
        self.available_toggle.set_sensitive(False)
        toolbar.insert(self.available_toggle, 4)
        self.installed_toggle = Gtk.RadioToolButton(
            label=_("Installed Software"), group=self.available_toggle)
        self.installed_toggle.set_property(
            "tooltip-text", _("Installed Software"))
        self.installed_toggle.set_icon_name("system")
        self.installed_toggle.connect(
            "toggled", self.all_or_installed, "installed")
        self.installed_toggle.set_sensitive(False)
        toolbar.insert(self.installed_toggle, 5)

        separatortoolitem = Gtk.SeparatorToolItem()
        toolbar.insert(separatortoolitem, 6)
        toolitem = Gtk.ToolItem()
        toolbar.insert(toolitem, 7)
        toolitem.set_expand(True)
        self.search_entry = Gtk.Entry()
        self.search_entry.set_icon_from_icon_name(
            Gtk.EntryIconPosition.PRIMARY, "search")
        self.search_entry.connect("key-release-event", self.search_release)
        self.search_entry.set_property("tooltip-text", _("Search Software"))
        self.search_entry.set_sensitive(False)
        hbox = Gtk.HBox(homogeneous=False, spacing=0)
        toolitem.add(hbox)
        hbox.show()
        hbox.pack_start(self.search_entry, False, False, 0)
        self.description_search = False
        self.search_description = Gtk.CheckButton(
            label=_("Search Description"))
        self.search_description.connect("toggled",
                                        self.search_description_toggled)
        self.search_description.set_sensitive(False)
        hbox.pack_start(self.search_description, False, False, 0)
        self.apply_button = Gtk.Button()
        self.apply_button.set_label(_("Apply"))
        apply_img = Gtk.Image.new_from_icon_name('gtk-apply', 1)
        self.apply_button.set_image(apply_img)
        self.apply_button.set_property(
            "tooltip-text", _("Apply change on the system"))
        self.apply_button.set_sensitive(False)
        hbox.pack_end(self.apply_button, False, False, 0)
        self.cancel_button = Gtk.Button()
        self.cancel_button.set_label(_("Cancel"))
        cancel_img = Gtk.Image.new_from_icon_name('gtk-cancel', 1)
        self.cancel_button.set_image(cancel_img)
        self.cancel_button.set_sensitive(False)
        self.cancel_button.set_property("tooltip-text", _("Cancel changes"))
        hbox.pack_end(self.cancel_button, False, False, 0)
        self.apply_button.connect("clicked", self.confirm_packages)
        self.cancel_button.connect("clicked", self.cancel_change)
        # Creating a notebook to switch
        self.mainstack = Gtk.Stack()
        self.mainstack.show()
        self.mainstack.set_transition_type(Gtk.StackTransitionType.SLIDE_LEFT)
        self.box1.pack_start(self.mainstack, True, True, 0)
        mainwin = self.main_book()
        self.mainstack.add_named(mainwin, "mainwin")
        self.pkg_statistic = Gtk.Label()
        self.pkg_statistic.set_use_markup(True)
        self.pkg_statistic.set_xalign(0.0)
        self.progress = Gtk.ProgressBar()
        self.progress.set_show_text(True)
        css = b'''
                progressbar > trough > progress {
                background-color: deepskyblue;
                }
        '''
        css_provider = Gtk.CssProvider()
        css_provider.load_from_data(css)
        context = Gtk.StyleContext()
        screen = Gdk.Screen.get_default()
        context.add_provider_for_screen(
            screen, css_provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)  # pylint: disable=no-member
        grid = Gtk.Grid()
        grid.set_column_spacing(10)
        grid.set_margin_start(10)
        grid.set_margin_end(10)
        grid.set_margin_top(10)
        grid.set_margin_bottom(10)
        grid.set_column_homogeneous(True)
        grid.set_row_homogeneous(True)
        grid.attach(self.pkg_statistic, 0, 0, 4, 1)
        grid.attach(self.progress, 4, 0, 6, 1)
        grid.show()
        self.box1.pack_start(grid, False, False, 0)
        # Initialize themed icon runtime (main thread)
        init_icons_runtime()

        self.show_all()  # pylint: disable=no-member
        self.initial_thread('initial')

    def search_description_toggled(self, widget):  # pylint: disable=unused-argument
        """Toggle whether to search package descriptions."""
        if widget.get_active():
            self.description_search = True
        else:
            self.description_search = False

    def toggle_description(self, widget):  # pylint: disable=unused-argument
        """Toggle the display of package descriptions in the UI."""
        self.desc_is_shown = not self.desc_is_shown
        if self.desc_is_shown:
            self.table.remove(self.pkg_sw)
            self.table.attach(self.pkg_sw, 2, 12, 0, 8)
            self.table.attach(self.description_sw, 2, 12, 8, 12)
            self.pkg_sw.show()
            self.description_sw.show_all()  # pylint: disable=no-member
        else:
            self.table.remove(self.pkg_sw)
            self.table.remove(self.description_sw)
            self.table.attach(self.pkg_sw, 2, 12, 0, 12)
            self.pkg_sw.show()

    def cancel_change(self, widget):  # pylint: disable=unused-argument
        """Cancel pending package changes and reset the UI."""
        # pylint: disable=global-statement
        global pkg_to_uninstall
        global pkg_to_install
        pkg_to_install = []
        pkg_to_uninstall = []
        pkg_selection = self.pkgtreeview.get_selection()
        model, selected_iter = pkg_selection.get_selected()
        try:
            pkg_path = model.get_path(selected_iter)
        except KeyError:
            nopath = True
        else:
            nopath = False

        try:
            self.search
        except AttributeError:
            self.update_pkg_store()
        else:
            self.update_search(self.search)
        if nopath is False:
            self.pkgtreeview.set_cursor(pkg_path)
        self.apply_button.set_sensitive(False)
        self.cancel_button.set_sensitive(False)

    def apply_change(self, widget):  # pylint: disable=unused-argument
        """Apply selected package changes."""
        self.confirm_window.hide()
        self.apply_thr = threading.Thread(target=self.apply_package_change,
                                          args=())
        self.apply_thr.start()

    def stop_apply_tread(self):
        """Stop the package change thread."""
        self.apply_thr.join()

    def apply_package_change(self):
        """Process package installation and uninstallation."""
        self.progress.show()
        # pylint: disable=global-statement
        global pkg_to_uninstall
        global pkg_to_install
        un_num = len(pkg_to_uninstall)
        in_num = len(pkg_to_install)
        num = un_num + (in_num * 2) + 1

        fraction = 0
        increment = 1.0 / num
        for pkg in pkg_to_uninstall:
            msg = _("Uninstalling")
            msg += f" {pkg}"
            GLib.idle_add(self.update_progress, self.progress, fraction, msg)
            dpkg = delete_packages(pkg)
            while True:
                line = dpkg.readline()
                if not line:
                    break
                msg = line.rstrip()
                GLib.idle_add(
                    self.update_progress, self.progress, fraction, msg)
            fraction += increment

        for pkg in pkg_to_install:
            msg = _("Fetching")
            msg += f" {pkg}"
            GLib.idle_add(self.update_progress, self.progress, fraction, msg)
            dpkg = fetch_packages(pkg)
            while True:
                line = dpkg.readline()
                if not line:
                    break
                msg = line.rstrip()
                GLib.idle_add(
                    self.update_progress, self.progress, fraction, msg)
            fraction += increment

        for pkg in pkg_to_install:
            msg = f"{_('Installing')} {pkg}"
            GLib.idle_add(self.update_progress, self.progress, fraction, msg)
            dpkg = install_packages(pkg)
            while True:
                line = dpkg.readline()
                if not line:
                    break
                msg = line.rstrip()
                GLib.idle_add(
                    self.update_progress, self.progress, fraction, msg)
            fraction += increment
        msg = _('Updating data')
        GLib.idle_add(self.update_progress, self.progress, fraction, msg)
        self.sync_available_packages()
        sleep(1)
        self.sync_installed_packages()
        pkg_to_install = []
        pkg_to_uninstall = []
        GLib.idle_add(self.apply_button.set_sensitive, False)
        GLib.idle_add(self.cancel_button.set_sensitive, False)
        fraction += increment
        msg = _('Completed')
        GLib.idle_add(self.update_progress, self.progress, fraction, msg)
        sleep(1)
        GLib.idle_add(self.progress.hide)
        GLib.idle_add(self.stop_apply_tread)
        self.unlock_ui()
        GLib.idle_add(self.unlock_ui)

    def all_or_installed(self, widget, data):
        """Switch between displaying all or installed packages."""
        if widget.get_active():
            self.available_or_installed = data
            if data == 'available':
                avail = self.available_pkg['avail']
                msg = _("Packages available:")
                self.pkg_statistic.set_text(f'<small>{msg} {avail}</small>')
                self.pkg_statistic.set_use_markup(True)
            else:
                installed = self.installed_pkg['avail']
                msg = _("Installed packages:")
                self.pkg_statistic.set_text(
                    f'<small>{msg} {installed}</small>')
                self.pkg_statistic.set_use_markup(True)
            self.search_entry.set_text('')
            self.update_pkg_store()

    def sync_available_packages(self):
        """Sync available package data."""
        self.available_category = available_package_origin()
        self.available_pkg = available_package_dictionary(
            self.available_category)

    def sync_installed_packages(self):
        """Sync installed package data."""
        self.installed_category = installed_package_origin()
        self.installed_pkg = installed_package_dictionary(
            self.installed_category)

    def update_progress(self, progress, fraction, msg):
        """Update the progress bar with the given fraction and message."""
        progress.set_fraction(fraction)
        progress.set_text(msg)

    def initial_sync(self):
        """Perform initial synchronization of package data."""
        self.pkg_statistic.set_text(_('<small>Syncing statistic</small>'))
        self.pkg_statistic.set_use_markup(True)
        self.network = network_stat()
        self.need_upgrade = False
        if self.network == 'UP':
            self.online = repo_online()
        else:
            self.online = False
        if self.online is True and repository_is_syncing() is False:
            msg = _('syncing with the repository')
            GLib.idle_add(self.update_progress, self.progress, 0.1, msg)
            if sync_with_repository() == 'UPGRADE':
                self.need_upgrade = True
            sleep(1)
            msg = _('syncing available packages')
            GLib.idle_add(self.update_progress, self.progress, 0.2, msg)
            self.sync_available_packages()
            sleep(1)
        msg = _('syncing installed packages')
        GLib.idle_add(self.update_progress, self.progress, 0.4, msg)
        self.sync_installed_packages()
        sleep(1)
        if self.online is True and repository_is_syncing() is False:
            avail = self.available_pkg['avail']
            msg = _("Packages available:")
            GLib.idle_add(
                self.pkg_statistic.set_text, f'<small>{msg} {avail}</small>')
            GLib.idle_add(self.pkg_statistic.set_use_markup, True)
        else:
            GLib.idle_add(self.installed_toggle.set_active, True)
        GLib.idle_add(self.update_progress, self.progress, 0.4, msg)
        msg = _('store packages categories')
        GLib.idle_add(self.update_progress, self.progress, 0.8, msg)
        sleep(0.5)
        GLib.idle_add(self.category_store_sync)
        sleep(1)
        msg = _('Completed')
        GLib.idle_add(self.update_progress, self.progress, 1.0, msg)
        sleep(1)
        self.progress.hide()
        GLib.idle_add(self.stop_tread)
        GLib.idle_add(self.unlock_ui)
        if self.online is False:
            GLib.idle_add(self.confirm_offline)
        elif repository_is_syncing():
            GLib.idle_add(self.confirm_offline)
        elif self.need_upgrade is True:
            GLib.idle_add(self.confirm_upgrade)

    def hide_window(self, button, window):  # pylint: disable=unused-argument
        """Hide the specified window."""
        window.hide()

    def confirm_offline(self):
        """Show a dialog for offline or syncing repository status."""
        window = Gtk.Window()
        window.set_title(_("Software Station"))
        window.connect("delete-event", Gtk.main_quit)
        window.set_keep_above(True)  # pylint: disable=no-member
        window.set_size_request(200, 80)
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)  # pylint: disable=no-member
        box1.show()
        msg = None
        if self.network == 'Down':
            msg = _('Network device is offline')
        elif self.online is False:
            msg = _("Can't reach software repository")
        elif repository_is_syncing():
            msg = _(
                "Software repositories are syncing with new software packages"
            )
        if msg:
            label = Gtk.Label(label=msg)
            box1.pack_start(label, True, True, 0)
        hbox = Gtk.HBox(homogeneous=False, spacing=0)
        hbox.show()
        box1.pack_end(hbox, False, False, 5)
        offline_button = Gtk.Button()
        offline_button.set_label(_("Use Offline"))
        apply_img = Gtk.Image.new_from_icon_name('gtk-ok', 1)
        offline_button.set_image(apply_img)
        offline_button.connect("clicked", self.hide_window, window)
        hbox.pack_end(offline_button, False, False, 5)
        close_button = Gtk.Button()
        close_button.set_label(_("Close"))
        apply_img = Gtk.Image.new_from_icon_name('gtk-close', 1)
        close_button.set_image(apply_img)
        close_button.connect("clicked", Gtk.main_quit)
        hbox.pack_end(close_button, False, False, 5)
        window.show_all()  # pylint: disable=no-member

    def start_upgrade(self, button):  # pylint: disable=unused-argument
        """Start the system upgrade process."""
        start_update_station()
        Gtk.main_quit()

    def confirm_upgrade(self):
        """Show a dialog prompting for system upgrade."""
        window = Gtk.Window()
        window.set_title(_("Upgrade Needed"))
        window.connect("delete-event", Gtk.main_quit)
        window.set_keep_above(True)  # pylint: disable=no-member
        window.set_size_request(200, 80)
        vbox = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(vbox)  # pylint: disable=no-member
        vbox.show()
        hbox = Gtk.HBox(homogeneous=False, spacing=0)
        hbox.show()
        vbox.pack_start(hbox, False, False, 10)
        title = _("<b>Warning this system needs to be upgraded!</b>")
        title_label = Gtk.Label(label=title)
        title_label.set_use_markup(True)
        title_label.set_justify(Gtk.Justification.CENTER)
        hbox.pack_start(title_label, True, True, 10)
        hbox = Gtk.HBox(homogeneous=False, spacing=0)
        hbox.show()
        vbox.pack_start(hbox, False, False, 5)
        msg = _("Installing software without upgrading could harm this "
                "installation.\nWould you like to upgrade now?")
        msg_label = Gtk.Label(label=msg)
        hbox.pack_start(msg_label, True, True, 20)
        hbox = Gtk.HBox(homogeneous=False, spacing=0)
        hbox.show()
        vbox.pack_end(hbox, False, False, 5)
        offline_button = Gtk.Button()
        offline_button.set_label(_("Yes"))
        apply_img = Gtk.Image.new_from_icon_name('gtk-yes', 1)
        offline_button.set_image(apply_img)
        offline_button.connect("clicked", self.start_upgrade)
        hbox.pack_end(offline_button, False, False, 5)
        close_button = Gtk.Button()
        close_button.set_label(_("No"))
        apply_img = Gtk.Image.new_from_icon_name('gtk-no', 1)
        close_button.set_image(apply_img)
        close_button.connect("clicked", self.hide_window, window)
        hbox.pack_end(close_button, False, False, 5)
        window.show_all()  # pylint: disable=no-member

    def unlock_ui(self):
        """Enable UI elements."""
        self.desc_toggle.set_sensitive(True)
        self.origin_treeview.set_sensitive(True)
        self.pkgtreeview.set_sensitive(True)
        if self.online is True and repository_is_syncing() is False:
            self.available_toggle.set_sensitive(True)
        self.installed_toggle.set_sensitive(True)
        if self.online is True and repository_is_syncing() is False:
            self.search_entry.set_sensitive(True)
            self.search_description.set_sensitive(True)

    def lock_ui(self):
        """Disable UI elements during operations."""
        self.desc_toggle.set_sensitive(False)
        self.search_entry.set_sensitive(False)
        self.search_description.set_sensitive(False)
        self.available_toggle.set_sensitive(False)
        self.installed_toggle.set_sensitive(False)
        self.origin_treeview.set_sensitive(False)
        self.pkgtreeview.set_sensitive(False)

    def stop_tread(self):
        """Stop the synchronization thread."""
        self.thr.join()

    def initial_thread(self, sync):  # pylint: disable=unused-argument
        """Start the initial synchronization thread."""
        self.thr = threading.Thread(target=self.initial_sync, args=())
        self.thr.start()

    def selected_software(self, view, event):  # pylint: disable=unused-argument
        """Handle package selection in the UI."""
        selection = self.pkgtreeview.get_selection()
        selection.get_selected()  # No-op, kept for compatibility

    def search_release(self, widget, event):  # pylint: disable=unused-argument
        """Handle search input events."""
        self.search = widget.get_text()
        try:
            if hasattr(self, 'previous_search'):
                globals()[f'stop_search_{self.previous_search}'] = True
        except (AttributeError, KeyError):
            pass
        if self.search:
            globals()[f'stop_search_{self.search}'] = False
            GLib.idle_add(self.update_search, self.search)
        else:
            GLib.idle_add(self.update_pkg_store)

        self.previous_search = self.search

    def update_search(self, search):
        """Update package search results."""
        if globals()[f'stop_search_{search}'] is True:
            return

        pixbuf = Gtk.IconTheme.get_default().load_icon('package-x-generic', 42, 0)

        if len(self.search) > 1:
            if globals()[f'stop_search_{search}'] is True:
                return

            self.category_tree_selection.unselect_all()
            self.pkg_store.clear()

            if globals()[f'stop_search_{search}'] is True:
                return

            for pkg in search_packages(search, self.description_search):
                if globals()[f'stop_search_{search}'] is True:
                    return

                pkg_data = self.available_pkg['all'].get(pkg, {})
                version = pkg_data.get('version', 'N/A')
                size = pkg_data.get('size', 'N/A')
                comment = pkg_data.get('comment', '')
                description = pkg_data.get('description', '')

                if pkg in pkg_to_install:
                    installed = True
                elif pkg in pkg_to_uninstall:
                    installed = False
                else:
                    installed = pkg_data.get('installed', False)

                it = self.pkg_store.append(
                    [pixbuf, pkg, version, size, comment, installed, description])

                def _on_ready(label, themed_pixbuf, it=it):
                    if themed_pixbuf is not None:
                        self.pkg_store.set(it, 0, themed_pixbuf)

                themed_icon_and_label_async(
                    getattr(self, 'category', ''), pkg, 42, _on_ready)

    def category_store_sync(self):
        """Sync package categories in the UI."""
        self.store.clear()
        self.search_entry.set_text('')
        if self.online is True and repository_is_syncing() is False:
            categories = self.available_category
        else:
            categories = self.installed_category
        for category in categories:
            xmp_data = xpm_package_category()[category]
            xmp = GdkPixbuf.Pixbuf.new_from_xpm_data(xmp_data)
            self.store.append([xmp, category])
        self.origin_treeview.set_cursor(0)

    def selection_category(self, tree_selection):
        """Handle category selection in the UI."""
        (model, pathlist) = tree_selection.get_selected_rows()
        if pathlist:
            path = pathlist[0]
            tree_iter = model.get_iter(path)
            self.category = model.get_value(tree_iter, 1)
            self.search_entry.set_text('')
            self.update_pkg_store()

    def update_pkg_store(self):
        """Update the package store with current data."""
        self.pkg_store.clear()
        pixbuf = Gtk.IconTheme.get_default().load_icon('package-x-generic', 42, 0)
        if self.available_or_installed == 'available':
            pkg_d = self.available_pkg[self.category]
        else:
            try:
                pkg_d = self.installed_pkg[self.category]
            except (KeyError, AttributeError):
                pkg_d = {}
        pkg_list = list(pkg_d.keys())
        for pkg in pkg_list:
            version = pkg_d[pkg]['version']
            size = pkg_d[pkg]['size']
            comment = pkg_d[pkg]['comment']
            description = pkg_d[pkg]['description']
            if pkg in pkg_to_install:
                installed = True
            elif pkg in pkg_to_uninstall:
                installed = False
            else:
                installed = pkg_d[pkg]['installed']
            it = self.pkg_store.append(
                [pixbuf, pkg, version, size, comment, installed, description])

            def _on_ready(label, themed_pixbuf, it=it):
                if themed_pixbuf is not None:
                    self.pkg_store.set(it, 0, themed_pixbuf)
            themed_icon_and_label_async(
                getattr(
                    self,
                    'category',
                    ''),
                pkg,
                42,
                _on_ready)

    def add_and_rm_pkg(self, cell, path, model):  # pylint: disable=unused-argument
        """Add or remove packages from install/uninstall lists."""
        model[path][5] = not model[path][5]
        pkg = model[path][1]
        if pkg not in pkg_to_uninstall and pkg not in pkg_to_install:
            if model[path][5] is False:
                pkg_to_uninstall.extend([pkg])
            else:
                pkg_to_install.extend([pkg])
        else:
            if pkg in pkg_to_uninstall and model[path][5] is True:
                pkg_to_uninstall.remove(pkg)
            elif pkg in pkg_to_install and model[path][5] is False:
                pkg_to_install.remove(pkg)
        if pkg not in pkg_to_uninstall and pkg not in pkg_to_install:
            self.apply_button.set_sensitive(False)
            self.cancel_button.set_sensitive(False)
        else:
            self.apply_button.set_sensitive(True)
            self.cancel_button.set_sensitive(True)

    def main_book(self):
        """Create the main notebook for package display."""
        self.table = Gtk.Table(n_rows=12, n_columns=12, homogeneous=True)
        self.table.show_all()
        category_sw = Gtk.ScrolledWindow()
        category_sw.set_shadow_type(
            Gtk.ShadowType.ETCHED_IN)  # pylint: disable=no-member
        category_sw.set_policy(Gtk.PolicyType.AUTOMATIC,
                               Gtk.PolicyType.AUTOMATIC)
        self.store = Gtk.ListStore(GdkPixbuf.Pixbuf, str)
        self.origin_treeview = Gtk.TreeView()
        self.origin_treeview.set_model(self.store)
        cell = Gtk.CellRendererPixbuf()
        column = Gtk.TreeViewColumn("Pixbuf", cell)
        column.add_attribute(cell, "pixbuf", 0)
        self.origin_treeview.append_column(column)
        cell2 = Gtk.CellRendererText()
        column2 = Gtk.TreeViewColumn(None, cell2, text=1)
        column2.set_attributes(cell2, text=1)
        self.origin_treeview.append_column(column2)
        self.origin_treeview.set_reorderable(True)
        self.origin_treeview.set_headers_visible(False)
        self.category_tree_selection = self.origin_treeview.get_selection()
        self.category_tree_selection.set_mode(Gtk.SelectionMode.SINGLE)
        self.category_tree_selection.connect(
            "changed", self.selection_category)
        self.origin_treeview.set_sensitive(False)
        category_sw.add(self.origin_treeview)  # pylint: disable=no-member
        category_sw.show()

        self.pkg_sw = Gtk.ScrolledWindow()
        self.pkg_sw.set_shadow_type(
            Gtk.ShadowType.ETCHED_IN)  # pylint: disable=no-member
        self.pkg_sw.set_policy(
            Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        self.pkg_store = Gtk.ListStore(
            GdkPixbuf.Pixbuf, str, str, str, str, bool, str)
        self.pkgtreeview = Gtk.TreeView()
        self.pkgtreeview.set_model(self.pkg_store)
        self.pkgtreeview.connect_after(
            "button_press_event", self.selected_software)
        self.check_cell = Gtk.CellRendererToggle()
        self.check_cell.set_property('activatable', True)
        self.check_cell.connect('toggled', self.add_and_rm_pkg, self.pkg_store)
        check_column = Gtk.TreeViewColumn(_("Check"), self.check_cell)
        check_column.add_attribute(self.check_cell, "active", 5)
        check_column.set_resizable(True)
        self.pkgtreeview.append_column(check_column)
        pixbuf_cell = Gtk.CellRendererPixbuf()
        pixbuf_column = Gtk.TreeViewColumn(_('Icon'), pixbuf_cell)
        pixbuf_column.add_attribute(pixbuf_cell, "pixbuf", 0)
        pixbuf_column.set_resizable(True)
        self.pkgtreeview.append_column(pixbuf_column)
        name_cell = Gtk.CellRendererText()
        name_column = Gtk.TreeViewColumn(_('Package Name'), name_cell, text=1)
        name_column.set_fixed_width(150)
        name_column.set_sort_column_id(1)
        name_column.set_resizable(True)
        self.pkgtreeview.append_column(name_column)
        version_cell = Gtk.CellRendererText()
        version_column = Gtk.TreeViewColumn(_('Version'), version_cell, text=2)
        version_column.set_fixed_width(100)
        version_column.set_sort_column_id(2)
        version_column.set_resizable(True)
        self.pkgtreeview.append_column(version_column)
        size_cell = Gtk.CellRendererText()
        size_column = Gtk.TreeViewColumn(_('Size'), size_cell, text=3)
        size_column.set_fixed_width(100)
        size_column.set_sort_column_id(3)
        size_column.set_resizable(True)
        comment_cell = Gtk.CellRendererText()
        comment_column = Gtk.TreeViewColumn(_('Comment'), comment_cell, text=4)
        comment_column.set_sort_column_id(4)
        comment_column.set_resizable(True)
        self.pkgtreeview.append_column(comment_column)
        self.pkgtreeview.set_tooltip_column(4)

        self.description_sw = Gtk.ScrolledWindow()
        self.description_sw.set_shadow_type(
            Gtk.ShadowType.ETCHED_IN)  # pylint: disable=no-member
        self.description_sw.set_policy(
            Gtk.PolicyType.AUTOMATIC,
            Gtk.PolicyType.AUTOMATIC
        )
        description_label = Gtk.Label(
            label=_("Click on a package to show its detailed description.")
        )
        self.description_sw.add_with_viewport(
            description_label)  # pylint: disable=no-member
        self.pkg_tree_selection = self.pkgtreeview.get_selection()
        self.pkgtreeview.set_sensitive(False)
        self.pkg_tree_selection.connect("changed", self.on_selection_changed,
                                        self.description_sw, description_label)
        self.pkg_sw.add(self.pkgtreeview)  # pylint: disable=no-member
        self.pkg_sw.show()
        self.table.attach(category_sw, 0, 2, 0, 12)
        self.table.attach(self.pkg_sw, 2, 12, 0, 12)
        self.show()
        return self.table

    def on_selection_changed(self, selection, description_sw, description_label):  # pylint: disable=unused-argument
        """Update package description when selection changes."""
        model, treeiter = selection.get_selected()
        if treeiter is not None:
            description_label.set_text(model[treeiter][6])
            self.description_sw.show_all()  # pylint: disable=no-member

    def hidewindow(self, widget):  # pylint: disable=unused-argument
        """Hide the confirmation window."""
        self.confirm_window.hide()
        self.cancel_change(None)
        self.unlock_ui()

    def delete_event(self, widget):  # pylint: disable=unused-argument
        """Handle window deletion events."""
        self.confirm_window.hide_on_delete()  # pylint: disable=no-member

    def create_bbox(self):
        """Create buttons for the confirmation dialog."""
        table = Gtk.Table(
            n_rows=1, n_columns=2, homogeneous=False, column_spacing=5)
        close_button = Gtk.Button(label=_("Cancel"))
        img = Gtk.Image.new_from_icon_name('gtk-cancel', 1)
        close_button.set_image(img)
        table.attach(close_button, 0, 1, 0, 1)
        close_button.connect("clicked", self.hidewindow)
        confirm_button = Gtk.Button(label=_("Confirm"))
        table.attach(confirm_button, 1, 2, 0, 1)
        confirm_button.connect("clicked", self.apply_change)
        return table

    def confirm_packages(self, widget):  # pylint: disable=unused-argument
        """Show the package confirmation dialog."""
        self.apply_button.set_sensitive(False)
        self.cancel_button.set_sensitive(False)
        self.lock_ui()
        self.confirm_window = Gtk.Window()
        self.confirm_window.connect("destroy", self.delete_event)
        self.confirm_window.set_size_request(600, 300)
        self.confirm_window.set_keep_above(True)  # pylint: disable=no-member
        self.confirm_window.set_title(_("Confirm software changes"))
        self.confirm_window.set_border_width(0)  # pylint: disable=no-member
        self.confirm_window.set_position(
            Gtk.WindowPosition.CENTER)  # pylint: disable=no-member
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.confirm_window.add(box1)  # pylint: disable=no-member
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=0)
        box2.set_border_width(5)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        titletext = _("Software changes to apply")
        titlelabel = Gtk.Label(
            label=f"<b><span size='large'>{titletext}</span></b>")
        titlelabel.set_use_markup(True)
        box2.pack_start(titlelabel, False, False, 0)
        self.tree_store = Gtk.TreeStore(str)
        sw = Gtk.ScrolledWindow()
        sw.set_shadow_type(
            Gtk.ShadowType.ETCHED_IN)  # pylint: disable=no-member
        sw.add(self.display(self.store_changes()))  # pylint: disable=no-member
        sw.show()
        box2.pack_start(sw, True, True, 5)
        box2 = Gtk.HBox(homogeneous=False, spacing=5)
        box2.set_border_width(5)
        box1.pack_start(box2, False, False, 5)
        box2.show()
        box2.pack_start(self.create_bbox(), True, True, 5)
        self.confirm_window.show_all()  # pylint: disable=no-member

    def display(self, model):
        """Display package changes in a tree view."""
        self.view = Gtk.TreeView(model=model)
        self.renderer = Gtk.CellRendererText()
        self.column0 = Gtk.TreeViewColumn(_("Name"), self.renderer, text=0)
        self.view.append_column(self.column0)
        self.view.set_headers_visible(False)
        self.view.expand_all()
        return self.view

    def store_changes(self):
        """Store package changes for display."""
        packages_dictionary = get_pkg_changes_data(
            pkg_to_uninstall, pkg_to_install)
        self.tree_store.clear()
        # pylint: disable=global-variable-undefined
        global total_num
        r_num = 0
        u_num = 0
        i_num = 0
        ri_num = 0
        if bool(packages_dictionary['remove']):
            r_num = len(packages_dictionary['remove'])
            message = f"{_('Installed packages to be REMOVED:')} {r_num}"
            r_pinter = self.tree_store.append(None, [message])
            for line in packages_dictionary['remove']:
                self.tree_store.append(r_pinter, [line])
        if bool(packages_dictionary['upgrade']):
            u_num = len(packages_dictionary['upgrade'])
            message = f"{_('Installed packages to be UPGRADED:')} {u_num}"
            u_pinter = self.tree_store.append(None, [message])
            for line in packages_dictionary['upgrade']:
                self.tree_store.append(u_pinter, [line])
        if bool(packages_dictionary['install']):
            i_num = len(packages_dictionary['install'])
            message = f"{_('New packages to be INSTALLED:')} {i_num}"
            i_pinter = self.tree_store.append(None, [message])
            for line in packages_dictionary['install']:
                self.tree_store.append(i_pinter, [line])
        if bool(packages_dictionary['reinstall']):
            ri_num = len(packages_dictionary['reinstall'])
            message = f"{_('Installed packages to be REINSTALL:')} {ri_num}"
            ri_pinter = self.tree_store.append(None, [message])
            for line in packages_dictionary['reinstall']:
                self.tree_store.append(ri_pinter, [line])
        total_num = r_num + u_num + i_num + ri_num
        return self.tree_store


class NotRoot(Gtk.Window):  # pylint: disable=missing-class-docstring
    def __init__(self):
        """Show a dialog indicating root privileges are required."""
        super().__init__()
        self.set_title(_("Software Station"))
        self.connect("delete-event", Gtk.main_quit)
        self.set_size_request(200, 80)
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.add(box1)  # pylint: disable=no-member
        box1.show()
        label = Gtk.Label(label=_('You need to be root'))
        box1.pack_start(label, True, True, 0)
        hbox = Gtk.HBox(homogeneous=False, spacing=0)
        hbox.show()
        box1.pack_end(hbox, False, False, 5)
        ok_button = Gtk.Button()
        ok_button.set_label(_("OK"))
        apply_img = Gtk.Image.new_from_icon_name('gtk-ok', 1)
        ok_button.set_image(apply_img)
        ok_button.connect("clicked", Gtk.main_quit)
        hbox.pack_end(ok_button, False, False, 5)
        self.show_all()  # pylint: disable=no-member


class Confirmation(Gtk.Window):  # pylint: disable=missing-class-docstring
    def confirm_passwd(self, widget, user):  # pylint: disable=unused-argument,redefined-outer-name
        """Verify the user's password against the stored SHA-512 hash."""
        print(f"Verifying password for user: {user}")
        try:
            # Read the stored hash from /etc/master.passwd
            stored_hash = None
            with open('/etc/master.passwd', 'r') as f:
                for line in f:
                    if line.startswith(f"{user}:"):
                        stored_hash = line.split(':')[1]
                        # Truncate for safety
                        print(f"Stored hash prefix: {stored_hash[:10]}...")
                        break
            if not stored_hash or stored_hash in ('x', '*'):
                print(f"No valid hash found for user {user}")
                self.hide()
                self.wrong_password()
                return

            # Verify the input password using SHA-512
            password = self.passwd.get_text()
            hashed_input = crypt.crypt(password, stored_hash)
            if hashed_input == stored_hash:
                print("Password verified successfully")
                self.hide()
                TableWindow()
            else:
                print("Password verification failed: incorrect password")
                self.hide()
                self.wrong_password()
        except Exception as e:
            print(f"Password verification error: {e}")
            self.hide()
            self.wrong_password()

    def wrong_password(self):
        """Show a dialog indicating an incorrect password."""
        window = Gtk.Window()
        window.set_title(_("Software Station"))
        window.connect("delete-event", Gtk.main_quit)
        window.set_size_request(200, 80)
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)  # pylint: disable=no-member
        box1.show()
        label = Gtk.Label(label=_('Wrong password'))
        box1.pack_start(label, True, True, 0)
        hbox = Gtk.HBox(homogeneous=False, spacing=0)
        hbox.show()
        box1.pack_end(hbox, False, False, 5)
        ok_button = Gtk.Button()
        ok_button.set_label(_("OK"))
        apply_img = Gtk.Image.new_from_icon_name('gtk-ok', 1)
        ok_button.set_image(apply_img)
        ok_button.connect("clicked", Gtk.main_quit)
        hbox.pack_end(ok_button, False, False, 5)
        window.show_all()  # pylint: disable=no-member

    def __init__(self, user):  # pylint: disable=redefined-outer-name
        """Initialize the password confirmation dialog."""
        super().__init__()
        self.set_title(_("Software Station"))
        self.connect("delete-event", Gtk.main_quit)
        self.set_size_request(200, 80)
        vbox = Gtk.VBox(homogeneous=False, spacing=0)
        self.add(vbox)  # pylint: disable=no-member
        vbox.show()
        label = f"{_('Confirm password for')} {user}"
        label_widget = Gtk.Label(label=label)
        vbox.pack_start(label_widget, True, True, 5)
        self.passwd = Gtk.Entry()
        self.passwd.set_visibility(False)
        self.passwd.connect("activate", self.confirm_passwd, user)
        hbox = Gtk.HBox(homogeneous=False, spacing=0)
        hbox.show()
        vbox.pack_start(hbox, False, False, 5)
        hbox.pack_start(self.passwd, True, True, 20)
        hbox2 = Gtk.HBox(homogeneous=False, spacing=0)
        hbox2.show()
        vbox.pack_end(hbox2, False, False, 5)
        ok_button = Gtk.Button()
        ok_button.set_label(_("OK"))
        apply_img = Gtk.Image.new_from_icon_name('gtk-ok', 1)
        ok_button.set_image(apply_img)
        ok_button.connect("clicked", self.confirm_passwd, user)
        hbox2.pack_end(ok_button, False, False, 5)
        self.show_all()  # pylint: disable=no-member


if os.geteuid() == 0:
    user = os.getenv("SUDO_USER")
    if user is None:
        TableWindow()
    else:
        Confirmation(user)
else:
    NotRoot()

Gtk.main()
